## Part 1. Установка ОС

1. Установлена Ubuntu 20.04 LTS без графического интерфейса.
2. Версия Ubuntu проверена командой `cat /etc/issue`.

   ![alt text](image.png)

## Part 2. Создание пользователя

1. Помимо изначального пользователя `jared` - был создан новый пользователь `ryan`;
2. Пользователь `ryan` добавлен в группу `adm`:

   ![alt text](image-2.png)
3. Вывод команды `cat /etc/passwd` (появился пользователь `ryan`):

   ![alt text](image-1.png)

## Part 3. Настройка сети ОС

<a name="network"></a>

1. Задано название машины user-1:

   ![alt text](image-3.png)

   ![](assets/20250410_050657_image.png)

   ![](assets/20250410_050814_image.png)
2. Установлена временная зона, соответствующая текущему местоположению:

   ![](assets/20250410_035639_image.png)
3. Выведены названия сетевых интерфейсов с помощью консольной команды `ip a`:

   ![](assets/20250410_040010_image.png)

   - Интерфейс lo это специальный виртуальный сетевой ***interface***, который компьютер используюет для взаимодействия с самим собой (localhost 127.0.0.1). Используется для диагностики и устранения неполадок, также используется для разработки.
4. Используя консольную команду, получен ip адрес устройства, на котором я работаю, от **DHCP-сервера**:

   ![](assets/20250410_041652_image.png)

   - **DHCP** - Dynamic Host Configuration Protocol (Протокол динамической настройки узла). Назначает сетевые параметры устройства внутри сети.
5. **Внешний** ip-адрес шлюза (ip) - `10.0.2.2`;
   И **внутренний** IP-адрес шлюза, он же ip-адрес по умолчанию (gw) - `10.0.2.15`:

   ![](assets/20250410_042350_image.png)
6. Заданы статичные настройки `ip`, `gw`, `dns`:

   ![](assets/20250418_123806_image.png)

   ![](assets/20250410_045056_image.png)
7. Перезагружаем виртуальную машину с помощью `reboot`. Убеждаемся, что статичные сетевые настройки сохранились:

   ![](assets/20250418_124109_image.png)

   - По порту `10.0.2.2` в routes виртуальная машина общается с основной, то есть это **виртуальный IP хоста** внутри NAT-сети.
8. Пропингованы `1.1.1.1` и `ya.ru` с сообщением **"0% packet loss"**:

   ![](assets/20250410_140915_image.png)

## Part 4. Обновление ОС

- Обновление системных пакетов с помощью пакетного менеджера apt командой `sudo apt update`, при повторной команде - "all packages are up to date":

  ![](assets/20250410_170851_image.png)

## Part 5. Использование команды sudo

1. Выдача прав на использование `sudo` пользователю `ryan`:

   ![](assets/20250410_171537_image.png)
2. **sudo (Super User DO)** - *временная* выдача полномочий суперпользователя пользователю, который им не является, при этом **не давая** полный доступ к системе.
3. Изменение имени машины аналогично [пункту 3](#network), от имени пользователья `ryan`, теперь имя машины - `bubusik2`:

   ![](assets/20250410_172740_image.png)

## Part 6. Установка и настройка службы времени

- Вывод `timedatectl` и `timedatectl show`:

  ![](assets/20250410_173214_image.png)

## Part 7. Установка и использование текстовых редакторов

1. Установка VIM, NANO, MICRO:

   ![](assets/20250410_173506_image.png)
2. Создание файла и добавление строки с сохранением изменений в трёх редакторах.

   - `test_vim.txt` и команда для сохранения и выхода `:wq`:

     ![](assets/20250410_173713_image.png)
   - `test_nano.txt`, сохранение - `ctrl + S`, выход - `ctrl + X`:

     ![](assets/20250410_174150_image.png)
   - `test_micro.txt`, сохранение - `ctrl + S`, выход - `ctrl + Q`:

     ![](assets/20250410_174443_image.png)
3. Изменение файла без сохранения изменений.

   - `test_vim.txt` для выхода без сохранения - `:q!`:

     ![](assets/20250410_175234_image.png)
   - `test_nano.txt` для выхода без сохранения - `ctrl + x` и следовать указаниям (при вопросе о сохранении нажать `N`, что значит "No"):

     ![](assets/20250410_175400_image.png)

     ![](assets/20250410_175545_image.png)
   - `test_micro.txt` для выхода без сохранения `ctrl + Q`, ниже всплывёт вопрос, нужно ли нам сохранить изменения - жмём `n`, чтобы выйти без сохранения:

     ![](assets/20250410_175708_image.png)
4. Повторное изменение файла и функции поиска слова.

   - `test_vim.txt` для поиска слова пишем `/` и искомое слово, оно подсветится в тексте и при нажатии `Enter` - курсор переместится в начало слова, выведется строка и символ начала искомого слова.

     ![](assets/20250410_180344_image.png)

     ![](assets/20250410_180532_image.png)

     Замена осуществляется командой `:s/что_меняем/на_что_меняем`:

     ![](assets/20250410_181613_image.png)
   - `test_nano.txt` для поиска слова используется функция **Where Is**, которая активируется нажатием `ctrl + W`. Замена активирутеся нажатием `ctrl + \`, далее следуем инструкциям:

     ![](assets/20250410_181917_image.png)

     ![](assets/20250410_182002_image.png)
   - `test_micro.txt` для поиска нажимаем `ctrl + F` и вбиваем искомое слово, редактор подсветит его в тексте и укажет, в какой строке нашёл его и с какого по счёту символа начинается слово:

     ![](assets/20250410_182155_image.png)

     Для замены используем `ctrl + E` и пишем `replace <что меняем> <на что меняем>`, а для словосочетаний с пробелами можем заключить в кавычки:

     ![](assets/20250410_182656_image.png)

     Далее подсвечивается заменяемое слово/словосочетание и спрашивается подтверждение замены, жмём `y` чтобы заменить:

     ![](assets/20250410_182808_image.png)

## Part 8. Установка и базовая настройка сервиса SSHD

1. Установка службы SSHd:

   ![](assets/20250410_183128_image.png)
2. Добавление сервера в автозагрузку (автостарт):

   ![](assets/20250410_183306_image.png)
3. Для настройки службы необходимо отредактировать файл `/etc/ssh/sshd_config`:

   ![](assets/20250410_183522_image.png)

   Далее необходимо раскомментировать и изменить параметр `Port`:

   ![](assets/20250410_183657_image.png)

   ![](assets/20250410_183746_image.png)
4. Команда `ps` (process status) - используется для определения работающих в системе программ и оценки используемых ими ресурсов. Ключ `-f` выводит **полную информацию** о процессе, ключ `-C` **фильтрует процесс по имени** (в нашем случае - `sshd`):

   ![](assets/20250410_190144_image.png)
5. Перезагружаем систему командой `reboot`.
6. `net-tools` не были установлены, так что устанавливаем командой `sudo apt install net-tools` и выполняем `netstat -tan`:

   ![](assets/20250410_191147_image.png)

   Вывод содержит `tcp 0 0 0.0.0.0:2022 0.0.0.0:* LISTEN`.
7. Значение ключей `-tan`:

   * `-t` — **показать только TCP**-подключения.
   * `-a` — **all**; все соединения (и слушающие, и установленные).
   * `-n` — **no name resolving**; не резолвить имена, показать IP/порты как числа (ускоряет вывод).
8. Значение столбцов:

   * **Proto** — протокол (`tcp` в нашем случае).
   * **Recv-Q** — сколько данных **принято** , но ещё **не прочитано** приложением.
   * **Send-Q** — сколько данных **отправлено** , но ещё **не подтверждено** другой стороной.
   * **Local Address** — локальный IP и порт, на которых слушает/общается процесс.
   * **Foreign Address** — удалённый IP и порт (с кем соединение).
   * **State** — состояние TCP-соединения (например, `LISTEN`, `ESTABLISHED`, `TIME_WAIT` и т.д.).
9. Что такое `0.0.0.0`?

   Это **универсальный IP**, означающий: «Слушаю **на всех** доступных интерфейсах»

   Примеры:

   - `0.0.0.0:22` — SSH-сервер слушает на всех IP машины (локалка, внешний IP, и т.д.)
   - `127.0.0.1:22` — слушает **только** на `localhost`, извне не подключишься

## Part 9. Установка и использование утилит top, htop

1. Установка утилит top и htop.

   - Утилита `top` уже предустановлена в системе, устанавливаем `htop` командой:

     ![](assets/20250410_193135_image.png)
2. Вывод команды `top`:

   ![](assets/20250410_194631_image.png)

   По выводу команды можем определить:

   - **uptime:** `19:45:27 up 2:21` -> машина работает **2 часа 21 минуту**.
   - **количество авторизованных пользователей:** `1 user` -> сейчас авторизован **1 пользователь**.
   - **среднюю загрузку системы:** `load average: 0.00, 0.00, 0.00`.
   - **общее количество процессов:** `Tasks: 108 total, 1 running, 103 sleeping, 4 stopped, 0 zombie` -> всего: **108 процессов**.
   - **загрузку cpu:** `%Cpu(s): 0.0 us, 0.0 sy, 0.0 ni, 99.8 id, ...`.

     - **загрузку памяти:**

       `MiB Mem : 1971.3 total, 1383.2 free, 172.4 used, 415.8 buff/cache `
       `MiB Swap: 1916.0 total, 1916.0 free, 0.0 used, 1640.8 avail Mem`

       -> ОЗУ:

       - всего: 1971.3 МБ
       - свободно: 1383.7 МБ
       - занято: 172. МБ

       -> swap вообще не трогали.
   - **pid процесса, занимающего больше всего памяти:** `1 root`, занимающий **0.7% памяти**.
   - **pid процесса, занимающего больше всего процессорного времени:** `2772 root`, **занимающий 0.3% процессорного времени** (по умолчанию процессы отсортированы по убыванию столбца CPU).
3. Вывод команды `htop`:

   - Отсортировано по `PID`:

     ![](assets/20250410_200109_image.png)
   - Отсортировано по `PERCENT_CPU`:

     ![](assets/20250410_200141_image.png)
   - Отсортировано по `PERCENT_MEM`:

     ![](assets/20250410_200214_image.png)
   - Отсортировано по `TIME`:

     ![](assets/20250410_200237_image.png)
   - Отфильтровано по процессу `sshd`:

     ![](assets/20250410_200342_image.png)
   - Процесс `syslog`, найденный через поиск:

     ![](assets/20250410_200434_image.png)
   - Добавлен вывод `hostname`, `clock` и `uptime`:

     ![](assets/20250410_200652_image.png)

## Part 10. Использование утилиты fdisk

- Команда `fdisk -l` - утилиты для работы с разделами дисков. Опция `-l` — **показывает все разделы всех доступных** дисков в системе.
  Её вывод (запускал через `sudo`, так как иначе отказывало в доступе):

  ![](assets/20250412_205605_image.png)
- Из снимка экрана можно узнать:

  1. Название диска: `/dev/sda`.
  2. Размер: `15 GiB` (15 гигабайт).
  3. Количество секторов: `31 456 280`.
  4. Отдельного раздела под swap в этой системе нет, однако командой `swapon --show` можно вывести название swap-файла:

     ![](assets/20250412_210059_image.png)

## Part 11. Использование утилиты df

1. Команда `df`:

   Одна из базовых команд для просмотра информации о файловых системах.

   ![](assets/20250412_211817_image.png)
   Возможно также вывести информацию о **конкретном разделе** (можно просто написать искомый раздел после команды - `df /`, а можно для большей читаемости написать с флагом `df -h /`, будет выведено в формате `human-readable`, то бишь исчисление данных в КБ, МБ, ГБ, ТБ и т.д).

   Вывод только **корневого раздела** будет таковым:

   ![](assets/20250412_212355_image.png)

   - размер раздела: 10 218 772.
   - размер занятого пространства: 5 106 540.
   - размер свободного пространства: 4 571 560.
   - процент использования: 53%.

   **P.S: Без флага `-h` команда `df` показывает размер в блоках по 1 КБ (килобайт)**.
2. Команда `df -Th`:

   Добавит столбец с типом файловой системы раздела (флаг `-T`) и выведет данные в человекочитаемом формате (`флаг -h`).

   ![](assets/20250412_213433_image.png)

   - размер раздела: 9.8 Гигабайт.
   - размер занятого пространства: 4.9 Гигабайт.
   - размер свободного пространства: 4.4 Гигабайта.
   - процент использования: 53%.

   Судя по выводу команды - корневой раздел `/` имеет тип файловой системы **ext4**.

## Part 12. Использование утилиты du

1. Вывод команды `du`:

   ![](assets/20250412_214445_image.png)
2. Размер папок `/home`, `/var`, `/var/log`:

   - В байтах:

     ![](assets/20250412_220103_image.png)
   - В человекочитаемом виде:

     ![](assets/20250412_220016_image.png)

   Команду использовал под `sudo`, т.к без прав суперпользователя не мог получить информацию о некоторых разделах.

   **Используемые флаги**:

   - Флаг `-s` **(summary)** - выводит **суммарный размер** указанных разделов без подробного вывода о каждом подразделе, т.е - **не показывает рекурсивно каждую вложенную папку**.
   - Флаг `-b` **(bytes)** - выводит в байтах.
   - Флаг `-h` **(human-readable)** - размер в KB/MB/GB.
3. Размер **всего содержимого** в `/var/log` (не общее, **а каждого вложенного элемента**, используя `*`):

   ![](assets/20250412_220355_image.png)

## Part 13. Установка и использование утилиты ncdu

Устанавливаем утилиту `ncdu` командой `sudo apt install ncdu`.

Вызов утилиты осуществляется командой `ncdu`. Можно сразу задать желаемую папку, например `ncdu /`.

- Размер и содержимое папки `/home`:

  ![](assets/20250412_220849_image.png)
- Размер и содержимое папки `/var`:

  ![](assets/20250412_221417_image.png)
- Размер и содержимое папки `/var/log`:

  ![](assets/20250412_221503_image.png)

## Part 14. Работа с системными журналами

1. Открыть для просмотра `/var/log/dmesg`, `/var/log/syslog`, `/var/log/auth.log`:

   - Вывод `less /var/log/dmesg`:

     ![](assets/20250412_222642_image.png)
   - Вывод `less /var/log/syslog`:

     ![](assets/20250412_222714_image.png)
   - Вывод `less /var/log/auth.log`:

     ![](assets/20250412_222742_image.png)
2. Ищем время последней успешной авторизации, имя пользователя и метод входа в систему.

   - В файле `/var/log/auth.log` ищем вручную или утилитой `grep` такие строки:

     ![](assets/20250412_223706_image.png)

     - Время: `Apr 12 22:34:02`
     - Имя пользователя: `jared`
     - Метод входа: `pam_unix(login:session)` ... `by LOGIN` — это **локальный вход в систему** через `tty` (физическая консоль или терминал) с помощью **login**.
3. Перезапуск службы `sshd`.

   - Выполним `sudo systemctl restart sshd` для перезапуска службы.
   - Ищем сообщение о рестарте в логах:

     ![](assets/20250412_224645_image.png)

## Part 15. Использование планировщика заданий CRON

1. Выполняем команду `crontab -e`, которая откроет нам файл в текстовом редакторе, где мы сможем как раз дать задачу для CRON.

   ![](assets/20250416_032550_image.png)
   Наша команда в конце файла, разберём подробнее, что значат все аргументы:

   \* \* \* \* \* <команда>
   │ │ │ │ │
   │ │ │ │ └─── День недели (0–7, где 0 и 7 = воскресенье)
   │ │ │ └───── Месяц (1–12)
   │ │ └─────── День месяца (1–31)
   │ └───────── Часы (0–23)
   └─────────── Минуты (0–59)

   В нашей команде мы должны выполнять `uptime` **каждые две минуты**, разберём её подробнее:

   - `*/2 * * * *` — каждые 2 минуты.
   - `uptime` — выполняемая команда.
   - `>>` — логируем в файл.
   - `2>&1` — кидаем туда же и ошибки.
2. Проверим через системные логи, что наша команда действительно выполняется (использовал команду
   `grep CRON /var/log/syslog | grep "uptime"`, можно также
   `journalctl | grep CRON | grep "uptime"` - вывод идентичен):

   ![](assets/20250416_030941_image.png)
3. Для отображения всех текущих задач воспользуемся командой `crontab -l`:

   ![](assets/20250416_030659_image.png)
4. Теперь удалим все текущие задачи CRON командой `crontab -r` и проверим, что задач больше нет командой `crontab -l`:

   ![](assets/20250416_031828_image.png)
